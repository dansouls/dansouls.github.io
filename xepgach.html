<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Game X·∫øp H√¨nh ‚Äî He He He</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#11182e; --accent:#6dd3ff; --text:#e7f0ff; --muted:#8aa0c7;
      --good:#5cf29d; --warn:#ffcc66; --bad:#ff6b6b;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      background: radial-gradient(1000px 600px at 20% -10%, #1b2447 0%, #0b1020 60%) fixed var(--bg);
      color:var(--text); display:flex; min-height:100svh; align-items:center; justify-content:center;
    }
    .wrap{display:grid; gap:16px; grid-template-columns: 1fr auto auto; padding:20px; width:min(1100px,95vw)}
    .board{
      background:linear-gradient(180deg,#0d1430,#0a0f24); border:1px solid #223;
      border-radius:20px; padding:16px; position:relative; box-shadow:0 10px 30px rgba(0,0,0,.4);
    }
    canvas{display:block; background: repeating-linear-gradient(180deg, rgba(255,255,255,.03) 0 2px, transparent 2px 24px);
      border-radius:12px; border:1px solid #2a375d}

    .side{display:grid; gap:16px}
    .card{background:var(--panel); border:1px solid #243052; border-radius:16px; padding:12px; box-shadow:0 8px 24px rgba(0,0,0,.35)}
    .card h3{margin:.2rem 0 .6rem; font-size:.95rem; color:var(--accent); letter-spacing:.3px}
    .mini{width:140px; height:140px; border-radius:10px; background:#0b132a; border:1px solid #1f2b4e}

    .hud{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px}
    .stat{font-variant-numeric:tabular-nums}
    .btns{display:grid; grid-template-columns:repeat(4,1fr); gap:8px}
    button{
      background:#14234a; color:var(--text); border:1px solid #273a6a; border-radius:12px; padding:10px 12px; 
      font-weight:600; cursor:pointer; transition:.15s transform,.2s background; user-select:none
    }
    button:hover{background:#183060}
    button:active{transform:translateY(1px)}
    .wide{grid-column:span 2}

    .footer{grid-column:1/-1; text-align:center; color:var(--muted); font-size:.9rem}
    .key{display:inline-block; border:1px solid #40507d; border-radius:8px; padding:2px 6px; font-weight:700; margin:0 2px; background:#0e1836}

    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr; justify-items:center}
      .side{grid-template-columns:repeat(2,auto)}
      .btns{grid-template-columns:repeat(4,1fr)}
      .mini{width:120px;height:120px}
    }
    @media (max-width: 520px){
      .side{grid-template-columns:1fr 1fr}
      .mini{width:96px;height:96px}
    }
  </style>
</head>
<body>
   <header>
    <h1>üî• D√¢n Souls</h1>
    <p>K√™nh YouTube chuy√™n v·ªÅ t·∫•t c·∫£ game kinh d·ªã th·ªãnh h√†nh</p>
  </header>
  <div class="wrap">
    <div class="board">
      <div class="hud">
        <div>
          <div><strong>ƒêi·ªÉm:</strong> <span id="score" class="stat">0</span></div>
          <div><strong>H√†ng:</strong> <span id="lines" class="stat">0</span></div>
          <div><strong>Level:</strong> <span id="level" class="stat">1</span></div>
        </div>
        <div>
          <button id="pauseBtn">T·∫°m d·ª´ng</button>
          <button id="restartBtn">Ch∆°i l·∫°i</button>
        </div>
      </div>
      <canvas id="game" width="300" height="600" aria-label="B·∫£ng x·∫øp h√¨nh" role="img"></canvas>
    </div>

    <div class="side">
      <div class="card">
        <h3>Next</h3>
        <canvas id="next" class="mini" width="140" height="140"></canvas>
      </div>
      <div class="card">
        <h3>Gi·ªØ (Hold)
          <span style="color:var(--muted); font-weight:400">‚Äî ph√≠m <span class="key">C</span></span>
        </h3>
        <canvas id="hold" class="mini" width="140" height="140"></canvas>
      </div>
      <div class="card">
        <h3>ƒêi·ªÅu khi·ªÉn</h3>
        <div style="line-height:1.6">
          <div><span class="key">‚Üê</span>/<span class="key">‚Üí</span> Di chuy·ªÉn</div>
          <div><span class="key">‚Üì</span> R∆°i nhanh ‚Ä¢ <span class="key">Space</span> R∆°i xu·ªëng</div>
          <div><span class="key">Z</span>/<span class="key">X</span> Xoay ‚Ä¢ <span class="key">C</span> Gi·ªØ</div>
          <div><span class="key">P</span> T·∫°m d·ª´ng</div>
        </div>
      </div>
      <div class="card">
        <h3>N√∫t ch·∫°m (mobile)</h3>
        <div class="btns">
          <button id="btnLeft">‚Üê</button>
          <button id="btnRight">‚Üí</button>
          <button id="btnRotateL">Z</button>
          <button id="btnRotateR">X</button>
          <button id="btnSoft" class="wide">‚Üì</button>
          <button id="btnHard" class="wide">R∆°i xu·ªëng</button>
          <button id="btnHold" class="wide">Gi·ªØ (C)</button>
          <button id="btnPause" class="wide">T·∫°m d·ª´ng</button>
        </div>
      </div>
    </div>

    <div class="footer">Made with ‚ù§ ‚Äî open-source. B·∫°n c√≥ th·ªÉ copy to√†n b·ªô file HTML n√†y ƒë·ªÉ ch·∫°y ngay.</div>
  </div>

  <script>
    // ====== C·∫•u h√¨nh c∆° b·∫£n ======
    const COLS = 10, ROWS = 20, SIZE = 30; // canvas 300x600
    const TICK_MIN = 70; // nhanh nh·∫•t

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const nextCanvas = document.getElementById('next');
    const nextCtx = nextCanvas.getContext('2d');
    const holdCanvas = document.getElementById('hold');
    const holdCtx = holdCanvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const linesEl = document.getElementById('lines');
    const levelEl = document.getElementById('level');

    const SCORES = {1:100, 2:300, 3:500, 4:800};

    // M√†u c√°c kh·ªëi
    const COLORS = {
      I:'#6dd3ff', J:'#5da2ff', L:'#ffc65c', O:'#ffe66d', S:'#5cf29d', T:'#cfa9ff', Z:'#ff6b6b', GHOST:'rgba(255,255,255,.18)'
    };

    // Ma tr·∫≠n c√°c m·∫£nh SRS (gi·ªØ k√≠ch th∆∞·ªõc vu√¥ng 3x3 ho·∫∑c 4x4 ƒë·ªÉ xoay ·ªïn ƒë·ªãnh)
    const SHAPES = {
      I:[
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]
      ],
      J:[
        [1,0,0],
        [1,1,1],
        [0,0,0]
      ],
      L:[
        [0,0,1],
        [1,1,1],
        [0,0,0]
      ],
      O:[
        [1,1],
        [1,1]
      ],
      S:[
        [0,1,1],
        [1,1,0],
        [0,0,0]
      ],
      T:[
        [0,1,0],
        [1,1,1],
        [0,0,0]
      ],
      Z:[
        [1,1,0],
        [0,1,1],
        [0,0,0]
      ]
    };

    const PIECES = Object.keys(SHAPES);

    // ====== Xoay vu√¥ng + wall kicks c∆° b·∫£n (·ªïn ƒë·ªãnh g·∫ßn t∆∞·ªùng/s√†n) ======
    function rotateSquare(matrix, dir){
      const N = matrix.length; // vu√¥ng N x N
      const res = Array.from({length:N},()=>Array(N).fill(0));
      for(let y=0;y<N;y++){
        for(let x=0;x<N;x++){
          const v = matrix[y][x];
          if(dir>0){ // quay ph·∫£i (CW)
            res[x][N-1-y] = v;
          } else {  // quay tr√°i (CCW)
            res[N-1-x][y] = v;
          }
        }
      }
      return res;
    }

    function createMatrix(w,h){
      return Array.from({length:h},()=>Array(w).fill(null));
    }

    // 7-bag randomizer
    let bag = [];
    function nextType(){
      if(bag.length===0){
        bag = [...PIECES];
        for(let i=bag.length-1;i>0;i--){
          const j=Math.random()* (i+1) | 0;
          [bag[i],bag[j]]=[bag[j],bag[i]];
        }
      }
      return bag.pop();
    }

    class Piece{
      constructor(type){
        this.type = type;
        // Sao ch√©p ma tr·∫≠n g·ªëc (vu√¥ng 2/3/4)
        this.matrix = SHAPES[type].map(r=>r.slice());
        this.x = Math.floor((COLS - this.matrix[0].length)/2);
        this.y = -2; // spawn h∆°i tr√™n
      }
      rotate(dir){
        const rotated = rotateSquare(this.matrix, dir);
        // Wall kicks t·ªïng qu√°t: th·ª≠ d·ªãch chuy·ªÉn nh·ªè quanh v·ªã tr√≠ hi·ªán t·∫°i
        const tests = [
          {x:0,y:0},
          {x:-1,y:0}, {x:1,y:0},
          {x:0,y:-1}, {x:0,y:-2},
          {x:-2,y:0}, {x:2,y:0},
          {x:-1,y:-1}, {x:1,y:-1}
        ];
        for(const t of tests){
          if(!collides(rotated, this.x + t.x, this.y + t.y)){
            this.matrix = rotated; this.x += t.x; this.y += t.y; return true;
          }
        }
        return false;
      }
    }

    // Tr·∫°ng th√°i game
    const state = {
      grid: createMatrix(COLS, ROWS),
      cur: null,
      nextQueue: [],
      hold:null,
      canHold:true,
      score:0, lines:0, level:1,
      dropCounter:0, dropInterval:1000,
      lastTime:0,
      paused:false,
      gameOver:false
    };

    function reset(){
      state.grid = createMatrix(COLS, ROWS);
      state.cur = new Piece(nextType());
      state.nextQueue = [nextType(), nextType(), nextType()];
      state.hold = null; state.canHold = true;
      state.score=0; state.lines=0; state.level=1; state.dropInterval=1000; state.dropCounter=0;
      state.paused=false; state.gameOver=false; updateHUD();
      drawAll();
    }

    function levelSpeed(level){
      return Math.max(1000 - (level-1)*80, TICK_MIN);
    }

    function updateLevel(linesCleared){
      state.lines += linesCleared;
      const newLevel = Math.floor(state.lines/10)+1;
      if(newLevel!==state.level){
        state.level = newLevel;
        state.dropInterval = levelSpeed(state.level);
      }
    }

    function collides(matrix, offsetX, offsetY){
      for(let y=0;y<matrix.length;y++){
        for(let x=0;x<matrix[y].length;x++){
          if(!matrix[y][x]) continue;
          const nx = offsetX + x;
          const ny = offsetY + y;
          if(ny < 0) continue; // cho ph√©p tr√™n ƒë·ªânh
          if(nx<0 || nx>=COLS || ny>=ROWS) return true;
          if(state.grid[ny][nx]) return true;
        }
      }
      return false;
    }

    function merge(){
      const {matrix,x,y,type} = state.cur;
      for(let j=0;j<matrix.length;j++){
        for(let i=0;i<matrix[j].length;i++){
          if(matrix[j][i]){
            const ny = y + j; const nx = x + i;
            if(ny>=0) state.grid[ny][nx] = type;
          }
        }
      }
    }

    function clearLines(){
      let cleared = 0;
      for(let y=ROWS-1;y>=0;y--){
        if(state.grid[y].every(cell=>cell)){
          state.grid.splice(y,1);
          state.grid.unshift(Array(COLS).fill(null));
          cleared++; y++;
        }
      }
      if(cleared){
        const SCORES = {1:100,2:300,3:500,4:800};
        state.score += (SCORES[cleared]||0) * state.level;
        updateLevel(cleared); updateHUD();
      }
    }

    function spawnNext(){
      state.cur = new Piece(state.nextQueue.shift());
      state.nextQueue.push(nextType());
      state.canHold = true;
      if(collides(state.cur.matrix, state.cur.x, state.cur.y)){
        state.gameOver = true; state.paused = true;
      }
    }

    function hardDrop(){
      while(!collides(state.cur.matrix, state.cur.x, state.cur.y+1)){
        state.cur.y++; state.score += 2; // th∆∞·ªüng nh·∫π hard drop
      }
      lockPiece();
    }

    function softDrop(){
      if(!collides(state.cur.matrix, state.cur.x, state.cur.y+1)){
        state.cur.y++; state.score += 1; updateHUD();
      } else {
        lockPiece();
      }
    }

    function move(dx){
      const nx = state.cur.x + dx;
      if(!collides(state.cur.matrix, nx, state.cur.y)) state.cur.x = nx;
    }

    function rotateCur(dir){
      state.cur.rotate(dir);
    }

    function hold(){
      if(!state.canHold) return;
      if(state.hold == null){
        state.hold = state.cur.type; spawnNext();
      } else {
        const tmp = state.hold; state.hold = state.cur.type; state.cur = new Piece(tmp);
      }
      state.canHold = false;
    }

    function lockPiece(){
      merge();
      clearLines();
      spawnNext();
      updateHUD();
    }

    function drawCell(x,y,color,ghost=false){
      const px = x*SIZE, py = y*SIZE;
      ctx.fillStyle = ghost? COLORS.GHOST : color;
      ctx.fillRect(px,py,SIZE,SIZE);
      if(!ghost){
        ctx.fillStyle = 'rgba(0,0,0,.15)';
        ctx.fillRect(px,py+SIZE-4,SIZE,4);
        ctx.fillStyle = 'rgba(255,255,255,.08)';
        ctx.fillRect(px,py, SIZE, 3);
      }
      ctx.strokeStyle = 'rgba(255,255,255,.06)';
      ctx.strokeRect(px+.5,py+.5,SIZE-1,SIZE-1);
    }

    function getGhostY(){
      let gy = state.cur.y;
      while(!collides(state.cur.matrix, state.cur.x, gy+1)) gy++;
      return gy;
    }

    function drawBoard(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if(state.grid[y][x]) drawCell(x,y,COLORS[state.grid[y][x]]);
        }
      }
      if(state.cur){
        const gy = getGhostY();
        // ghost
        for(let j=0;j<state.cur.matrix.length;j++){
          for(let i=0;i<state.cur.matrix[j].length;i++){
            if(state.cur.matrix[j][i]){
              const gx = state.cur.x + i; const gy2 = gy + j;
              if(gy2>=0) drawCell(gx, gy2, COLORS.GHOST, true);
            }
          }
        }
        // current
        for(let j=0;j<state.cur.matrix.length;j++){
          for(let i=0;i<state.cur.matrix[j].length;i++){
            if(state.cur.matrix[j][i]){
              const nx = state.cur.x + i; const ny = state.cur.y + j;
              if(ny>=0) drawCell(nx, ny, COLORS[state.cur.type]);
            }
          }
        }
      }

      if(state.gameOver){
        drawOverlay('GAME OVER\nNh·∫•n Ch∆°i l·∫°i');
      } else if(state.paused){
        drawOverlay('T·∫†M D·ª™NG');
      }
    }

    function drawOverlay(text){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center'; ctx.textBaseline='middle';
      ctx.font = '700 26px system-ui,Segoe UI,Roboto';
      for(const [i,line] of text.split('\n').entries()){
        ctx.fillText(line, canvas.width/2, canvas.height/2 + i*32);
      }
      ctx.restore();
    }

    function drawMini(ctx2, type){
      ctx2.clearRect(0,0,ctx2.canvas.width, ctx2.canvas.height);
      if(!type) return;
      const matrix = SHAPES[type];
      const cell = 24; // k√≠ch th∆∞·ªõc √¥ nh·ªè
      const w = matrix[0].length * cell, h = matrix.length * cell;
      const ox = Math.floor((ctx2.canvas.width - w)/2);
      const oy = Math.floor((ctx2.canvas.height - h)/2);
      for(let y=0;y<matrix.length;y++){
        for(let x=0;x<matrix[y].length;x++){
          if(matrix[y][x]){
            ctx2.fillStyle = COLORS[type];
            ctx2.fillRect(ox+x*cell, oy+y*cell, cell, cell);
            ctx2.fillStyle = 'rgba(0,0,0,.15)';
            ctx2.fillRect(ox+x*cell, oy+y*cell+cell-3, cell, 3);
            ctx2.strokeStyle = 'rgba(255,255,255,.08)';
            ctx2.strokeRect(ox+x*cell+.5, oy+y*cell+.5, cell-1, cell-1);
          }
        }
      }
    }

    function drawNextHold(){
      drawMini(nextCtx, state.nextQueue[0]);
      drawMini(holdCtx, state.hold);
    }

    function drawAll(){
      drawBoard();
      drawNextHold();
    }

    function updateHUD(){
      scoreEl.textContent = state.score;
      linesEl.textContent = state.lines;
      levelEl.textContent = state.level;
    }

    // ====== Game Loop ======
    function update(time=0){
      const delta = time - state.lastTime; state.lastTime = time;
      if(!state.paused && !state.gameOver){
        state.dropCounter += delta;
        if(state.dropCounter >= state.dropInterval){
          state.dropCounter = 0; softDrop();
        }
      }
      drawAll();
      requestAnimationFrame(update);
    }

    // ====== Input ======
    const keys = {
      ArrowLeft: ()=>move(-1),
      ArrowRight: ()=>move(1),
      ArrowDown: ()=>softDrop(),
      Space: ()=>hardDrop(),
      KeyZ: ()=>rotateCur(-1),
      KeyX: ()=>rotateCur(1),
      KeyC: ()=>hold(),
      KeyP: togglePause,
    };

    document.addEventListener('keydown', (e)=>{
      const code = e.code || e.key;
      if(code==='Space') e.preventDefault();
      const fn = keys[code]; if(fn){ fn(); }
    });

    function togglePause(){
      if(state.gameOver) return;
      state.paused = !state.paused;
    }

    // Buttons (mobile)
    const on = (id, fn)=> document.getElementById(id).addEventListener('click', fn);
    on('btnLeft', ()=>move(-1));
    on('btnRight', ()=>move(1));
    on('btnRotateL', ()=>rotateCur(-1));
    on('btnRotateR', ()=>rotateCur(1));
    on('btnSoft', ()=>softDrop());
    on('btnHard', ()=>hardDrop());
    on('btnHold', ()=>hold());
    on('btnPause', ()=>togglePause());

    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('restartBtn').addEventListener('click', reset);

    // ====== Start ======
    reset();
    requestAnimationFrame(update);
  </script>
</body>
</html>
